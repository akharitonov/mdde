from typing import Tuple, Sequence

import numpy as np

from . import DefaultAgent
from mdde.agent.abc import NodeAgentMapping


class SingleNodeDefaultAgent(DefaultAgent):
    """Default agent allowing only a single data node to be managed. Generates a uniform action space."""

    def __init__(self,
                 agent_name: str,
                 agent_id: int,
                 data_node_id: str,
                 group: str = DefaultAgent.DEFAULT_GROUP,
                 write_stats: bool = False,
                 allow_do_nothing: bool = True):
        """
        Single node default agent constructor
        :param agent_name: Name of the agent instance.
        :param agent_id: Unique ID of the agent within the experimental run.
        :param data_node_id: Data node managed by the agent.
        :param group: (optional) Group of the agent.
        :param write_stats: (optional) If True - agent will write some data (description of it's action space), to the
        results folder provided in `self._config` for later analysis.
        :param allow_do_nothing: (optional) If True - when the agent generates its action space, it will add a
        'do_nothing' action at 0. Otherwise the agent must always take an action.
        """
        super().__init__(agent_name=agent_name,
                         agent_id=agent_id,
                         data_node_ids=[data_node_id],
                         group=group,
                         write_stats=write_stats,
                         allow_do_nothing=allow_do_nothing)

    def create_action_space(self,
                            nodes: Tuple[NodeAgentMapping, ...],
                            fragments: Sequence[str],
                            obs: np.ndarray,
                            ) -> int:
        """
        Generates an action space size: 1 + len(nodes) * len(fragments) * 2.
        Action 0 is a do nothing action. For each node a two sets of actions will be created: copy a fragment to self,
        delete fragment from self. It's not allowed, however, to remove fragments from other agents or copy from node
        to the very same node. These constraints will be observed by the registry. It's beneficial to have ownership
        of the node indicated in the observation space.
        """
        own_node = self.data_node_ids[0]
        n_frags = len(fragments)
        cur_act_idx = 0
        if self._allow_do_nothing:
            a_actions = np.empty(1 + len(nodes) * n_frags + n_frags, dtype=object)
            a_actions[0] = self.Action(node_source_id=None,
                                       node_destination_id=None,
                                       fragment_id=None,
                                       is_del=False)  # do nothing action
            cur_act_idx += 1
        else:
            a_actions = np.empty(len(nodes) * n_frags + n_frags, dtype=object)

        # Delete actions
        for frag_idx, frag_reg_id in enumerate(fragments, cur_act_idx):
            # Delete
            a_actions[frag_idx] = self.Action(node_source_id=own_node,
                                              node_destination_id=None,
                                              fragment_id=frag_reg_id,
                                              is_del=True)
        cur_act_idx = cur_act_idx + n_frags
        # Copy actions per node
        for node in nodes:
            for frag_idx, frag_reg_id in enumerate(fragments, cur_act_idx):
                a_actions[frag_idx] = self.Action(node_source_id=node.node_id,
                                                  node_destination_id=own_node,
                                                  fragment_id=frag_reg_id,
                                                  is_del=False)

            cur_act_idx = cur_act_idx + n_frags

        self._actions = a_actions
        if self._write_stats:  # Save descriptions for later analysis
            self._dumpActions()
        return len(self._actions)

    def filter_observation(self,
                           obs_descr: Tuple[NodeAgentMapping, ...],
                           fragments: Tuple[str, ...],
                           obs: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """Expecting the observation space generated by the default scenario. Agent appends a new axis to the
        observation array marking own nodes with 1, foreign with 0."""
        own = np.zeros((len(obs_descr), 1), dtype=np.int8)
        legal_act = np.zeros((len(self._actions)), dtype=np.int8)
        node_idx = -1
        for own_node_idx in [obs_descr.index(own_node) for own_node in obs_descr if own_node.agent_id == self.id]:
            own[own_node_idx][0] = 1
            node_idx = own_node_idx
        # TODO: Refactor legal actions portion (make efficient after the logic of this experimental code stabilizes)
        if node_idx > -1:  # Generate a binary map of actions, where 1 means action should be legal in current state.
            # own node and observation
            own_node = self.data_node_ids[0]
            own_observation = obs[node_idx]

            # collect foreign nodes observations into a map
            foreign_nodes_map = {}
            for f_node_idx, f_node_id in {obs_descr.index(node): node.node_id
                                      for node in obs_descr if node.agent_id != self.id}.items():
                foreign_nodes_map[f_node_id] = obs[f_node_idx]

            if self._allow_do_nothing:  # agent can always do nothing if it's allowed in the current scenario
                legal_act[0] = 1

            for action_idx, action in enumerate(self._actions):
                action_fragment_id = action.fragment_id

                if action_fragment_id is None:
                    # Skip the actions that don't deal with any fragment, for this agent it's only `do_nothing`
                    continue
                action_fragment_obs_idx = fragments.index(action_fragment_id)
                node_has_copy = own_observation[action_fragment_obs_idx][0]

                # delete actions
                if action.is_del and node_has_copy:
                    # verify if the fragment is unique(can't remove a unique fragment)
                    f_unique = True
                    for f_node_id, f_node_obs in foreign_nodes_map.items():
                        if f_node_obs[action_fragment_obs_idx][1]:
                            f_unique = False
                            break
                    if not f_unique:
                        legal_act[action_idx] = 1
                # copy actions
                else:
                    if action.node_source_id != own_node \
                            and action.node_destination_id is not None \
                            and not node_has_copy:
                        # check if the designated source contains the action
                        source_has_copy = foreign_nodes_map[action.node_source_id][action_fragment_obs_idx][0]
                        if source_has_copy:
                            legal_act[action_idx] = 1

        return np.insert(obs, 2, own, axis=2), legal_act
